---
sidebar: sidebar 
permalink: openshift/osv-vm-dp-using-tp.html 
keywords: OpenShift, OCP, Trident, Trident protect, NetApp ONTAP, Red Hat OpenShift, OpenShift Virtualization, CNV, Container Native Virtualization, Red Hat OpenShift Virtualization,Data Protection, Data Management for VMs, VM protection 
summary: Red Hat OpenShift 虚拟化数据保护与NetApp ONTAP 
---
= 使用Trident Protect 保护 Red Hat OpenShift 虚拟化中的虚拟机
:hardbreaks:
:allow-uri-read: 
:nofooter: 
:icons: font
:linkattrs: 
:imagesdir: ../media/


[role="lead"]
使用快照和备份保护 OpenShift 虚拟化中的虚拟机。此过程包括使用ONTAP S3 对象存储创建 AppVault、配置Trident Protect 以捕获 VM 数据（包括 Kubernetes 资源对象、持久卷和内部图像），并在必要时恢复数据。

OpenShift 虚拟化环境中的虚拟机是在 OpenShift 容器平台的工作节点中运行的容器化应用程序。保护虚拟机元数据以及虚拟机的持久磁盘非常重要，以便在它们丢失或损坏时可以恢复它们。

OpenShift 虚拟化虚拟机的持久磁盘可由集成到 OpenShift 集群的ONTAP存储支持，使用link:https://docs.netapp.com/us-en/trident/["Trident犯罪现场调查"]。在本节中我们使用link:https://docs.netapp.com/us-en/trident/trident-protect/learn-about-trident-protect.html["Trident保护"]创建虚拟机（包括其数据卷）的快照和备份到ONTAP对象存储。

然后，我们在需要时从快照或备份中恢复。

Trident Protect 支持 OpenShift 集群上的应用程序和虚拟机的快照、备份、恢复和灾难恢复。对于 OpenShift 虚拟化虚拟机，可以使用Trident Protect 保护的数据包括与虚拟机关联的 Kubernetes 资源对象、持久卷和内部图像。

**以下是本节示例使用的各个组件的版本**

* link:https://docs.redhat.com/en/documentation/openshift_container_platform/4.17/html/installing_on_bare_metal/index["OpenShift 集群 4.17"]
* link:https://docs.redhat.com/en/documentation/openshift_container_platform/4.17/html/virtualization/getting-started#tours-quick-starts_virt-getting-started["通过 Red Hat 提供的 OpenShift Virtualization Operator 安装 OpenShift Virtualization"]
* link:https://docs.netapp.com/us-en/trident/trident-get-started/kubernetes-deploy.html["Trident25.02"]
* link:https://docs.netapp.com/us-en/trident/trident-protect/trident-protect-installation.html["Trident保护 25.02"]
* link:https://docs.netapp.com/us-en/ontap/["ONTAP 9.16"]




== 为对象存储创建 App Vault

.创建 AppVault
[%collapsible%open]
====
在为应用程序或虚拟机创建快照和备份之前，必须在Trident Protect 中配置对象存储来存储快照和备份。这是使用存储桶 CR 完成的。只有管理员可以创建存储桶 CR 并对其进行配置。在Trident Protect 中，存储桶 CR 被称为 AppVault。AppVault 对象是存储桶的声明性 Kubernetes 工作流表示。AppVault CR 包含存储桶在保护操作（例如备份、快照、恢复操作和SnapMirror复制）中使用的必要配置。

在此示例中，我们将展示如何使用ONTAP S3 作为对象存储。以下是为ONTAP S3 创建 AppVault CR 的工作流程： 1.在ONTAP集群中的 SVM 中创建 S3 对象存储服务器。2.在对象存储服务器中创建一个存储桶。3.在 SVM 中创建 S3 用户。将访问密钥和密钥保存在安全的地方。4.在 OpenShift 中，创建一个密钥来存储ONTAP S3 凭证。5.为ONTAP S3 创建 AppVault 对象

**为ONTAP S3 配置Trident保护 AppVault**

[source, yaml]
----
# alias tp='tridentctl-protect'

# cat appvault-secret.yaml
apiVersion: v1
stringData:
  accessKeyID: "<access key of S3>"
  secretAccessKey: "<secret access key of S3>"
# you can also provide base 64 encoded values instead of string values
#data:
# base 64 encoded values
#  accessKeyID: < base 64 encoded access key>
#  secretAccessKey: <base 64 encoded secretAccess key>
kind: Secret
metadata:
  name: appvault-secret
  namespace: trident-protect
type: Opaque

# cat appvault.yaml
apiVersion: protect.trident.netapp.io/v1
kind: AppVault
metadata:
  name: ontap-s3-appvault
  namespace: trident-protect
spec:
  providerConfig:
    azure:
      accountName: ""
      bucketName: ""
      endpoint: ""
    gcp:
      bucketName: ""
      projectID: ""
    s3:
      bucketName: trident-protect
      endpoint: <lif for S3 access>
      secure: "false"
      skipCertValidation: "true"
  providerCredentials:
    accessKeyID:
      valueFromSecret:
        key: accessKeyID
        name: appvault-secret
    secretAccessKey:
      valueFromSecret:
        key: secretAccessKey
        name: appvault-secret
  providerType: OntapS3

# oc create -f appvault-secret.yaml -n trident-protect
# oc create -f appvault.yaml -n trident-protect
----
image:rh-os-n-use-case-ocpv-tp-dp-008.png["ONTAP S3 Appvault 已创建"]

====


== 在 OpenShift Virtualization 中创建 VM

.在 OpenShift Virtualization 中创建 VM
[%collapsible%open]
====
以下屏幕截图显示了使用模板从控制台创建 VM（命名空间 demo 中的 demo-fedora）。根磁盘会自动选择默认存储类别，因此，请验证默认存储类别是否设置得当。在此设置中，默认存储类是**sc-zonea-san**。确保在创建附加磁盘时选择存储类 sc-zonea-san 并选中“**应用优化存储设置**”复选框。这会将访问模式设置为 RWX，将卷模式设置为阻止。


NOTE: Trident支持 SAN（iSCSI、NVMe/TCP 和 FC）块卷模式下的 RWX 访问模式。（这是NAS的默认访问模式）。如果您稍后需要对虚拟机进行实时迁移，则需要 RWX 访问模式。

image:rh-os-n-use-case-ocpv-tp-dp-001.png["默认存储类"]

image:rh-os-n-use-case-ocpv-tp-dp-002.png["创建 Fedora 虚拟机"]

image:rh-os-n-use-case-ocpv-tp-dp-003.png["模板默认值"]

image:rh-os-n-use-case-ocpv-tp-dp-004.png["定制"]

image:rh-os-n-use-case-ocpv-tp-dp-005.png["添加磁盘"]

image:rh-os-n-use-case-ocpv-tp-dp-006.png["已添加磁盘"]

image:rh-os-n-use-case-ocpv-tp-dp-007.png["已创建 vm、pod 和 pvc"]

====


== 创建应用程序

.创建应用程序
[%collapsible%open]
====
**为虚拟机创建一个 Trident 保护应用程序**

在示例中，demo 命名空间有一个 VM，并且在创建应用程序时包含了该命名空间的所有资源。

[source, yaml]
----
# alias tp='tridentctl-protect'
# tp create app demo-vm --namespaces demo -n demo --dry-run > app.yaml

# cat app.yaml
apiVersion: protect.trident.netapp.io/v1
kind: Application
metadata:
  creationTimestamp: null
  name: demo-vm
  namespace: demo
spec:
  includedNamespaces:
  - namespace: demo
# oc create -f app.yaml -n demo
----
image:rh-os-n-use-case-ocpv-tp-dp-009.png["应用程序已创建"]

====


== 通过创建备份来保护应用程序

.创建备份
[%collapsible%open]
====
**创建按需备份**

为之前创建的应用程序（demo-vm）创建一个备份，其中包括 demo 命名空间中的所有资源。提供将存储备份的 appvault 名称。

[source, yaml]
----
# tp create backup demo-vm-backup-on-demand --app demo-vm --appvault ontap-s3-appvault -n demo
Backup "demo-vm-backup-on-demand" created.
----
image:rh-os-n-use-case-ocpv-tp-dp-015.png["按需备份已创建"]

**按计划创建备份**

创建备份计划，指定要保留的备份粒度和数量。

[source, yaml]
----
# tp create schedule backup-schedule1 --app demo-vm --appvault ontap-s3-appvault --granularity Hourly --minute 45 --backup-retention 1 -n demo --dry-run>backup-schedule-demo-vm.yaml
schedule.protect.trident.netapp.io/backup-schedule1 created

#cat backup-schedule-demo-vm.yaml
apiVersion: protect.trident.netapp.io/v1
kind: Schedule
metadata:
  creationTimestamp: null
  name: backup-schedule1
  namespace: demo
spec:
  appVaultRef: ontap-s3-appvault
  applicationRef: demo-vm
  backupRetention: "1"
  dayOfMonth: ""
  dayOfWeek: ""
  enabled: true
  granularity: Hourly
  hour: ""
  minute: "45"
  recurrenceRule: ""
  snapshotRetention: "0"
status: {}
# oc create -f backup-schedule-demo-vm.yaml -n demo
----
image:rh-os-n-use-case-ocpv-tp-dp-016.png["备份计划已创建"]

image:rh-os-n-use-case-ocpv-tp-dp-017.png["按需和按计划创建备份"]

====


== 从备份还原

.从备份还原
[%collapsible%open]
====
**将虚拟机恢复到相同的命名空间**

在示例中，备份 demo-vm-backup-on-demand 包含 fedora VM 的 demo-app 备份。

首先，删除虚拟机，并确保 PVC、pod 和虚拟机对象从命名空间“demo”中删除

image:rh-os-n-use-case-ocpv-tp-dp-019.png["fedora-vm 已删除"]

现在，创建一个就地备份恢复对象。

[source, yaml]
----
# tp create bir demo-fedora-restore --backup demo/demo-vm-backup-on-demand -n demo --dry-run>vm-demo-bir.yaml

# cat vm-demo-bir.yaml
apiVersion: protect.trident.netapp.io/v1
kind: BackupInplaceRestore
metadata:
  annotations:
    protect.trident.netapp.io/max-parallel-restore-jobs: "25"
  creationTimestamp: null
  name: demo-fedora-restore
  namespace: demo
spec:
  appArchivePath: demo-vm_cc8adc7a-0c28-460b-a32f-0a7b3d353e13/backups/demo-vm-backup-on-demand_f6af3513-9739-480e-88c7-4cca45808a80
  appVaultRef: ontap-s3-appvault
  resourceFilter: {}
status:
  postRestoreExecHooksRunResults: null
  state: ""

# oc create -f vm-demo-bir.yaml -n demo
backupinplacerestore.protect.trident.netapp.io/demo-fedora-restore created
----
image:rh-os-n-use-case-ocpv-tp-dp-020.png["创建"]

验证虚拟机、Pod 和 PVC 是否已恢复

image:rh-os-n-use-case-ocpv-tp-dp-021.png["VM 已恢复并创建"]

**将虚拟机还原到不同的命名空间**

首先创建一个要将应用程序恢复到的新命名空间，在本例中为 demo2。然后创建备份恢复对象

[source, yaml]
----
# tp create br demo2-fedora-restore --backup demo/hourly-4c094-20250312154500 --namespace-mapping demo:demo2 -n demo2 --dry-run>vm-demo2-br.yaml

# cat vm-demo2-br.yaml
apiVersion: protect.trident.netapp.io/v1
kind: BackupRestore
metadata:
  annotations:
    protect.trident.netapp.io/max-parallel-restore-jobs: "25"
  creationTimestamp: null
  name: demo2-fedora-restore
  namespace: demo2
spec:
  appArchivePath: demo-vm_cc8adc7a-0c28-460b-a32f-0a7b3d353e13/backups/hourly-4c094-20250312154500_aaa14543-a3fa-41f1-a04c-44b1664d0f81
  appVaultRef: ontap-s3-appvault
  namespaceMapping:
  - destination: demo2
    source: demo
  resourceFilter: {}
status:
  conditions: null
  postRestoreExecHooksRunResults: null
  state: ""
# oc create -f vm-demo2-br.yaml -n demo2
----
image:rh-os-n-use-case-ocpv-tp-dp-022.png["br 创建"]

验证是否在新命名空间 demo2 中创建了 VM、pod 和 pvc。

image:rh-os-n-use-case-ocpv-tp-dp-023.png["新命名空间中的虚拟机"]

====


== 使用快照保护应用程序

.创建快照
[%collapsible%open]
====
**创建按需快照** 为应用程序创建快照并指定需要存储它的 appvault。

[source, yaml]
----
# tp create snapshot demo-vm-snapshot-ondemand --app demo-vm --appvault ontap-s3-appvault -n demo --dry-run
# cat demo-vm-snapshot-on-demand.yaml
apiVersion: protect.trident.netapp.io/v1
kind: Snapshot
metadata:
  creationTimestamp: null
  name: demo-vm-snapshot-ondemand
  namespace: demo
spec:
  appVaultRef: ontap-s3-appvault
  applicationRef: demo-vm
  completionTimeout: 0s
  volumeSnapshotsCreatedTimeout: 0s
  volumeSnapshotsReadyToUseTimeout: 0s
status:
  conditions: null
  postSnapshotExecHooksRunResults: null
  preSnapshotExecHooksRunResults: null
  state: ""

# oc create -f demo-vm-snapshot-on-demand.yaml
snapshot.protect.trident.netapp.io/demo-vm-snapshot-ondemand created

----
image:rh-os-n-use-case-ocpv-tp-dp-023.png["按需快照"]

**为快照创建计划** 为快照创建计划。指定要保留的粒度和快照数量。

[source, yaml]
----
# tp create Schedule snapshot-schedule1 --app demo-vm --appvault ontap-s3-appvault --granularity Hourly --minute 50 --snapshot-retention 1 -n demo --dry-run>snapshot-schedule-demo-vm.yaml

# cat snapshot-schedule-demo-vm.yaml
apiVersion: protect.trident.netapp.io/v1
kind: Schedule
metadata:
  creationTimestamp: null
  name: snapshot-schedule1
  namespace: demo
spec:
  appVaultRef: ontap-s3-appvault
  applicationRef: demo-vm
  backupRetention: "0"
  dayOfMonth: ""
  dayOfWeek: ""
  enabled: true
  granularity: Hourly
  hour: ""
  minute: "50"
  recurrenceRule: ""
  snapshotRetention: "1"
status: {}

# oc create -f snapshot-schedule-demo-vm.yaml
schedule.protect.trident.netapp.io/snapshot-schedule1 created
----
image:rh-os-n-use-case-ocpv-tp-dp-025.png["快照计划"]

image:rh-os-n-use-case-ocpv-tp-dp-026.png["计划快照"]

====


== 从快照还原

.从快照还原
[%collapsible%open]
====
**将虚拟机从快照恢复到同一个命名空间** 从 demo2 命名空间中删除虚拟机 demo-fedora。

image:rh-os-n-use-case-ocpv-tp-dp-030.png["虚拟机删除"]

从虚拟机的快照创建快照就地恢复对象。

[source, yaml]
----
# tp create sir demo-fedora-restore-from-snapshot --snapshot demo/demo-vm-snapshot-ondemand -n demo --dry-run>vm-demo-sir.yaml

# cat vm-demo-sir.yaml
apiVersion: protect.trident.netapp.io/v1
kind: SnapshotInplaceRestore
metadata:
  creationTimestamp: null
  name: demo-fedora-restore-from-snapshot
  namespace: demo
spec:
  appArchivePath: demo-vm_cc8adc7a-0c28-460b-a32f-0a7b3d353e13/snapshots/20250318132959_demo-vm-snapshot-ondemand_e3025972-30c0-4940-828a-47c276d7b034
  appVaultRef: ontap-s3-appvault
  resourceFilter: {}
status:
  conditions: null
  postRestoreExecHooksRunResults: null
  state: ""

# oc create -f vm-demo-sir.yaml
snapshotinplacerestore.protect.trident.netapp.io/demo-fedora-restore-from-snapshot created
----
image:rh-os-n-use-case-ocpv-tp-dp-027.png["先生"]

验证虚拟机及其 PVC 是否在 demo 命名空间中创建。

image:rh-os-n-use-case-ocpv-tp-dp-031.png["虚拟机在同一个命名空间中恢复"]

**将虚拟机从快照还原到不同的命名空间**

删除先前从备份中恢复的 demo2 命名空间中的虚拟机。

image:rh-os-n-use-case-ocpv-tp-dp-028.png["删除虚拟机、PVC"]

从快照创建快照恢复对象并提供命名空间映射。

[source, yaml]
----
# tp create sr demo2-fedora-restore-from-snapshot --snapshot demo/demo-vm-snapshot-ondemand --namespace-mapping demo:demo2 -n demo2 --dry-run>vm-demo2-sr.yaml

# cat vm-demo2-sr.yaml
apiVersion: protect.trident.netapp.io/v1
kind: SnapshotRestore
metadata:
  creationTimestamp: null
  name: demo2-fedora-restore-from-snapshot
  namespace: demo2
spec:
  appArchivePath: demo-vm_cc8adc7a-0c28-460b-a32f-0a7b3d353e13/snapshots/20250318132959_demo-vm-snapshot-ondemand_e3025972-30c0-4940-828a-47c276d7b034
  appVaultRef: ontap-s3-appvault
  namespaceMapping:
  - destination: demo2
    source: demo
  resourceFilter: {}
status:
  postRestoreExecHooksRunResults: null
  state: ""

# oc create -f vm-demo2-sr.yaml
snapshotrestore.protect.trident.netapp.io/demo2-fedora-restore-from-snapshot created
----
image:rh-os-n-use-case-ocpv-tp-dp-029.png["SR 创建"]

验证虚拟机及其 PVC 是否在新的命名空间 demo2 中恢复。

image:rh-os-n-use-case-ocpv-tp-dp-032.png["虚拟机在新的命名空间中恢复"]

====


== 恢复特定虚拟机

.选择命名空间中的特定虚拟机来创建快照/备份和恢复
[%collapsible%open]
====
在前面的例子中，我们在命名空间内有一个虚拟机。通过将整个命名空间包含在备份中，可以捕获与该虚拟机相关的所有资源。在下面的示例中，我们将另一个 VM 添加到同一个命名空间，并使用标签选择器为这个新 VM 创建一个应用程序。

**在 demo 命名空间中创建一个新的虚拟机（demo-centos vm）**

image:rh-os-n-use-case-ocpv-tp-dp-010.png["demo 命名空间中的 demo-centos VM"]

***标记 demo-centos vm 及其相关资源***

image:rh-os-n-use-case-ocpv-tp-dp-011.png["标签 demo-centos vm, pvc"]

***验证 demo-centos vm 和 pvcs 是否已获得标签***

image:rh-os-n-use-case-ocpv-tp-dp-012.png["demo-centos vm 标签"]

image:rh-os-n-use-case-ocpv-tp-dp-013.png["demo-centos pvc 获得标签"]

**使用标签选择器仅为特定虚拟机（demo-centos）创建应用程序**

[source, yaml]
----
# tp create app demo-centos-app --namespaces 'demo(category=protect-demo-centos)' -n demo --dry-run>demo-centos-app.yaml

# cat demo-centos-app.yaml

apiVersion: protect.trident.netapp.io/v1
kind: Application
metadata:
  creationTimestamp: null
  name: demo-centos-app
  namespace: demo
spec:
  includedNamespaces:
  - labelSelector:
      matchLabels:
        category: protect-demo-centos
    namespace: demo
status:
  conditions: null

# oc create -f demo-centos-app.yaml -n demo
application.protect.trident.netapp.io/demo-centos-app created
----
image:rh-os-n-use-case-ocpv-tp-dp-014.png["demo-centos pvc 获得标签"]

按需和按计划创建备份和快照的方法与前面所示的相同。由于用于创建快照或备份的 trident-protect 应用程序仅包含来自命名空间的特定 VM，因此从它们恢复只会恢复特定的 VM。下面显示了一个备份/恢复操作的示例。

**使用其对应的应用程序创建命名空间中特定虚拟机的备份**

在前面的步骤中，使用标签选择器创建了一个应用程序，以仅包含演示命名空间中的 centos vm。为此应用程序创建备份（在本例中为按需备份）。

[source, yaml]
----
# tp create backup demo-centos-backup-on-demand --app demo-centos-app --appvault ontap-s3-appvault -n demo
Backup "demo-centos-backup-on-demand" created.
----
image:rh-os-n-use-case-ocpv-tp-dp-018.png["创建特定虚拟机的备份"]

**将特定的 VM 恢复到同一个命名空间** 使用相应的应用程序创建了特定的 VM（centos）的备份。如果从此创建了备份就地恢复或备份恢复，则仅恢复此特定的 VM。删除 Centos VM。

image:rh-os-n-use-case-ocpv-tp-dp-033.png["Centos VM 存在"]

image:rh-os-n-use-case-ocpv-tp-dp-034.png["Centos 虚拟机已删除"]

从 demo-centos-backup-on-demand 创建备份就地恢复并验证 centos VM 是否已重新创建。

[source, yaml]
----
#tp create bir demo-centos-restore --backup demo/demo-centos-backup-on-demand -n demo
BackupInplaceRestore "demo-centos-restore" created.
----
image:rh-os-n-use-case-ocpv-tp-dp-035.png["创建 CentOS 虚拟机 bir"]

image:rh-os-n-use-case-ocpv-tp-dp-036.png["centos 虚拟机已创建"]

**将特定的 VM 恢复到不同的命名空间** 从 demo-centos-backup-on-demand 创建到不同命名空间 (demo3) 的备份恢复，并验证 centos VM 是否已重新创建。

[source, yaml]
----
# tp create br demo2-centos-restore --backup demo/demo-centos-backup-on-demand --namespace-mapping demo:demo3 -n demo3
BackupRestore "demo2-centos-restore" created.
----
image:rh-os-n-use-case-ocpv-tp-dp-037.png["创建 CentOS 虚拟机 bir"]

image:rh-os-n-use-case-ocpv-tp-dp-038.png["centos 虚拟机已创建"]

====


== 视频演示

以下视频演示了如何使用快照保护虚拟机

.保护虚拟机
video::4670e188-3d67-4207-84c5-b2d500f934a0[panopto,width=360]